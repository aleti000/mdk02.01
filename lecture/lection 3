# Лекция 3: Управление процессами в Linux

## Цели и задачи
- Изучить принципы управления процессами в Linux.
- Разобраться с жизненным циклом процессов.
- Научиться использовать команды для работы с процессами.
- Понять, как работает планировщик задач и приоритеты процессов.

## Основной материал

---

### 1. Что такое процесс?

Процесс — это выполняемая программа, которая использует ресурсы системы (процессор, память, диски). Каждый процесс имеет уникальный идентификатор (PID) и связан с пользователем, который его запустил.

#### Структура процесса:
- **PID**: Уникальный идентификатор процесса.
- **PPID**: Идентификатор родительского процесса.
- **UID/GID**: Идентификаторы пользователя и группы, от имени которых запущен процесс.
- **Nice value**: Приоритет процесса (от -20 до 19).
- **Статус**: Текущее состояние процесса.

#### Состояния процесса:
1. **Running**: Процесс выполняется на процессоре или находится в очереди на выполнение.
2. **Sleeping**: Процесс ожидает завершения операции (например, чтение данных с диска или сетевого соединения).
3. **Stopped**: Процесс приостановлен (например, сигналом `SIGSTOP`).
4. **Zombie**: Процесс завершился, но его запись в таблице процессов еще не удалена. Зомби-процессы не используют ресурсы, но занимают место в таблице процессов.

Пример:
Чтобы посмотреть список всех процессов, используйте команду:
ps aux

Для просмотра зомби-процессов:
ps aux | grep Z

---

### 2. Команды для работы с процессами

#### Основные команды:
- `ps`: Просмотр активных процессов.
  - `ps aux`: Показывает все процессы в системе.
  - `ps -ef`: Альтернативный формат вывода.
- `top`: Динамический мониторинг процессов.
  - Показывает использование CPU, памяти и другие метрики.
  - Горячие клавиши:
    - `k`: Завершение процесса.
    - `r`: Изменение приоритета.
- `kill`: Завершение процесса.
  - `kill PID`: Отправляет сигнал `SIGTERM` (завершение).
  - `kill -9 PID`: Отправляет сигнал `SIGKILL` (принудительное завершение).
- `nice` и `renice`: Управление приоритетами процессов.
- `bg` и `fg`: Перемещение процессов между фоновым и передним планом.

Пример:
Запустите процесс в фоновом режиме:
sleep 100 &
Переместите процесс на передний план:
fg %1

---

### 3. Жизненный цикл процесса

Каждый процесс проходит несколько этапов:

1. **Создание**:
   - Процесс создается с помощью системного вызова `fork`. Родительский процесс создает копию самого себя.
   - После создания процесс может заменить свой код новой программой с помощью системного вызова `exec`.

2. **Выполнение**:
   - Процесс выполняет свои задачи, используя ресурсы системы.
   - Процесс может быть приостановлен, возобновлен или завершен.

3. **Завершение**:
   - Процесс завершается с помощью системного вызова `exit`.
   - Родительский процесс должен "подтвердить" завершение дочернего процесса, чтобы освободить его запись в таблице процессов.

#### Типы процессов:
- **Foreground**: Процесс выполняется в интерактивном режиме (например, текстовый редактор).
- **Background**: Процесс выполняется в фоновом режиме (например, демон).

Пример:
Запустите процесс в фоновом режиме:
sleep 100 &
Переместите процесс на передний план:
fg %1

---

### 4. Планировщик задач

Планировщик задач (scheduler) — это часть ядра Linux, которая отвечает за распределение времени процессора между процессами. Он решает, какой процесс будет выполняться в данный момент, и как долго он будет использовать процессор. В Linux используются несколько алгоритмов планирования, каждый из которых имеет свои особенности.

#### Основные алгоритмы планирования:

1. **CFS (Completely Fair Scheduler)**:
   - **Описание**: CFS — это основной алгоритм планирования задач в современных версиях Linux. Он используется для обычных процессов (не реального времени).
   - **Принцип работы**:
     - CFS стремится обеспечить "справедливое" распределение времени процессора между всеми процессами.
     - Каждому процессу выделяется равное количество времени на выполнение.
     - Процессы с более высоким приоритетом получают больше времени на выполнение, но все процессы в конечном итоге получат доступ к процессору.
   - **Nice value**: Приоритет процесса определяется значением `nice`. Чем выше значение `nice`, тем ниже приоритет процесса (диапазон от -20 до 19).
   - **Временные интервалы**:
     - CFS не использует фиксированные временные кванты (time slices). Вместо этого он динамически вычисляет, сколько времени процесс может использовать процессор, исходя из его приоритета.
   - **Пример**:
     nice -n 10 sleep 100

2. **Round-Robin Scheduling**:
   - **Описание**: Round-Robin — это простой алгоритм планирования, который используется для процессов с одинаковым приоритетом.
   - **Принцип работы**:
     - Все процессы помещаются в очередь.
     - Каждый процесс получает равное количество времени на выполнение (фиксированный временной квант).
     - После завершения временного кванта процесс перемещается в конец очереди.
   - **Преимущества**:
     - Простота реализации.
     - Обеспечивает равномерное распределение времени процессора.
   - **Недостатки**:
     - Не учитывает приоритеты процессов.
     - Может быть неэффективным для процессов с разными требованиями к ресурсам.

3. **Real-Time Scheduling**:
   - **Описание**: Real-Time Scheduler используется для процессов, которые требуют немедленного выполнения (например, системы управления оборудованием или мультимедийные приложения).
   - **Типы реального времени**:
     - **SCHED_FIFO**: Процесс выполняется до тех пор, пока он не завершится или не будет вытеснен процессом с более высоким приоритетом.
     - **SCHED_RR**: Похож на SCHED_FIFO, но использует временные кванты. Если процесс не завершился за выделенное время, он перемещается в конец очереди.
   - **Приоритеты**:
     - Реальные процессы имеют приоритеты от 1 до 99.
     - Чем выше приоритет, тем раньше процесс получит доступ к процессору.
   - **Пример**:
     chrt -f 50 sleep 100

4. **Batch Scheduling**:
   - **Описание**: Batch Scheduler используется для процессов, которые не требуют немедленного выполнения и могут быть выполнены в фоновом режиме.
   - **Принцип работы**:
     - Процессы с низким приоритетом выполняются только тогда, когда система не занята другими задачами.
     - Идеально подходит для задач, которые могут быть выполнены в любое время (например, резервное копирование).
   - **Пример**:
     ionice -c 3 sleep 100

5. **Idle Scheduling**:
   - **Описание**: Idle Scheduler используется для процессов, которые выполняются только тогда, когда система простаивает.
   - **Принцип работы**:
     - Эти процессы не мешают другим процессам и выполняются только в свободное время.
     - Используется для задач, которые не требуют срочного выполнения (например, фоновая индексация файлов).
   - **Пример**:
     ionice -c 2 -n 7 sleep 100

#### Как работает планировщик задач в Linux:
1. **Очереди процессов**:
   - Процессы помещаются в очереди в зависимости от их приоритета.
   - Высокоприоритетные процессы выполняются первыми.
   - Низкоприоритетные процессы выполняются только тогда, когда нет других задач.

2. **Динамическое изменение приоритетов**:
   - Ядро Linux динамически изменяет приоритеты процессов в зависимости от их поведения.
   - Например, если процесс часто использует процессор, его приоритет снижается.

3. **Мультипроцессорные системы**:
   - В системах с несколькими процессорами планировщик распределяет процессы между ядрами.
   - Это позволяет эффективно использовать ресурсы и минимизировать задержки.

---

### 5. Мониторинг процессов

Для мониторинга процессов используются утилиты:
- `top`: Динамический мониторинг процессов.
- `htop`: Улучшенная версия `top` с удобным интерфейсом.
- `iotop`: Мониторинг операций ввода-вывода.
- `pidstat`: Статистика по процессам.

Пример:
Запустите мониторинг процессов:
top

---

### 6. Сигналы и управление процессами

Сигналы — это способ взаимодействия с процессами. Например:
- `SIGTERM`: Завершение процесса.
- `SIGKILL`: Принудительное завершение процесса.
- `SIGSTOP`: Приостановка процесса.
- `SIGCONT`: Возобновление приостановленного процесса.

Пример:
Отправьте сигнал `SIGSTOP` процессу:
kill -SIGSTOP 1234

Возобновите процесс:
kill -SIGCONT 1234

---

### 7. Демоны (daemons)

Демоны — это процессы, работающие в фоновом режиме и обеспечивающие работу системных сервисов. Они обычно запускаются при загрузке системы и работают постоянно.

#### Примеры демонов:
- `sshd`: Сервер SSH.
- `httpd`: Веб-сервер Apache.
- `crond`: Планировщик задач.

#### Управление демонами:
- `systemctl start <service>`: Запуск службы.
- `systemctl stop <service>`: Остановка службы.
- `systemctl status <service>`: Проверка статуса службы.

Пример:
Проверьте статус демона SSH:
systemctl status sshd

---

## Домашнее задание
1. Исследовать процессы на вашей системе:
   - Используйте команды `ps`, `top`, `htop`.
2. Запустите процесс в фоновом режиме и переместите его на передний план.
3. Измените приоритет процесса с помощью `nice` и `renice`.
4. Отправьте сигнал `SIGSTOP` и `SIGCONT` процессу.
5. Проверьте статус демона SSH и перезапустите его.

## Вопросы для самопроверки
1. Что такое процесс?
2. Какие состояния может иметь процесс?
3. Как завершить процесс в Linux?
4. Что такое планировщик задач и как он работает?
5. Как изменить приоритет процесса?
6. Как отправить сигнал процессу?
7. Что такое демоны и как их проверить?
