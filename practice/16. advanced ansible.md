**Лабораторная работа №__ по теме: Написание и использование Ansible Playbook’ов на ALT Linux (продолжение)**

---

### **Цель работы**  
Освоить принципы создания и применения **Ansible Playbook’ов** в операционной системе **ALT Linux**. Научиться описывать автоматизированные задачи в виде YAML-файлов, использовать модули, переменные, обработчики и управлять конфигурацией группы хостов в сегментированной сети, где доступ к изолированному серверу (VM2) осуществляется через бастион-хост (VM1).

---

### **Задачи работы**
1. Повторно проверить сетевую и SSH-конфигурацию, созданную в предыдущей лабораторной работе.
2. Изучить структуру и синтаксис Ansible Playbook’а.
3. Создать простой playbook для проверки состояния системы.
4. Разработать расширенный playbook, выполняющий несколько задач: создание пользователя, управление пакетами, копирование файлов, перезапуск служб.
5. Использовать переменные и обработчики (handlers).
6. Запустить и отладить playbook.

---

### **Методические указания**

#### **Теоретическая часть**

**Playbook** — это файл в формате **YAML**, описывающий последовательность задач, которые Ansible должен выполнить на одном или нескольких хостах. В отличие от ad-hoc команд, playbook’и позволяют:
- Описывать сложные сценарии,
- Обеспечивать идемпотентность (повторяемость без побочных эффектов),
- Управлять состоянием системы,
- Документировать конфигурацию.

**Основные элементы Playbook’а:**
- `hosts` — на каких хостах выполнять задачи,
- `tasks` — список задач,
- `vars` — переменные,
- `handlers` — действия, запускаемые по уведомлению (например, перезапуск службы),
- `become` — повышение привилегий (аналог `sudo`),
- `modules` — встроенные функции Ansible (`copy`, `user`, `service`, `yum`, и др.).

> Playbook’и работают **идемпотентно**: если система уже в нужном состоянии — изменения не применяются.

---

### **Практическая часть**

> ⚠️ **Важно:** Данная лабораторная работа выполняется **на основе предыдущей**. Предполагается, что:
> - VM1 имеет Bridge и внутреннюю сеть,
> - VM2 подключена только к внутренней сети,
> - SSH настроен, ключи скопированы,
> - Ansible установлен на VM1,
> - Файлы `inventory.ini` и `ansible.cfg` уже существуют,
> - Пользователь `ansible_user` существует на обеих машинах.

---

#### **Шаг 1: Проверка готовности среды**

Перейдите в рабочий каталог:

```bash
cd ~/ansible-project
```

Проверьте инвентаризацию:

```bash
ansible-inventory --list
```

Протестируйте связь:

```bash
ansible vm2 -m ping
```

> Должен вернуться ответ: `"ping": "pong"`

---

#### **Шаг 2: Структура и синтаксис Playbook’а**

Playbook — это YAML-файл, состоящий из одного или нескольких **play’ов**.

Пример базовой структуры:

```yaml
---
- name: Описание первого play
  hosts: vm2
  become: yes
  vars:
    user_name: dev_user
  tasks:
    - name: Описание задачи
      module_name:
        parameter1: value1
        parameter2: value2
  handlers:
    - name: Перезапуск службы
      service:
        name: sshd
        state: restarted
```

> **Правила YAML:**
> - Отступы важны (пробелы, не табуляция),
> - Двоеточие после ключа,
> - Списки начинаются с `-`.

---

#### **Шаг 3: Создание простого Playbook**

Создайте файл:

```bash
nano simple_playbook.yml
```

Содержимое:

```yaml
---
- name: Простой playbook для проверки системы
  hosts: vm2
  gather_facts: yes
  tasks:
    - name: Проверка имени хоста
      command: hostname
      register: result_hostname

    - name: Вывод результата
      debug:
        var: result_hostname.stdout

    - name: Создание тестового файла
      copy:
        content: "Этот файл создан Ansible\n"
        dest: /home/ansible_user/test_created_by_ansible.txt
        owner: ansible_user
        mode: '0644'
```

> **Объяснение:**
> - `gather_facts: yes` — собирает информацию о системе,
> - `register` — сохраняет результат команды в переменную,
> - `debug` — выводит значение переменной.

Запустите playbook:

```bash
ansible-playbook simple_playbook.yml
```

> Убедитесь, что файл создан на VM2.

---

#### **Шаг 4: Расширенный Playbook с переменными и обработчиками**

Создайте:

```bash
nano advanced_playbook.yml
```

```yaml
---
- name: Настройка сервера VM2
  hosts: vm2
  become: yes
  vars:
    app_user: webdev
    package_name: nginx
    config_file: /etc/nginx/nginx.conf

  handlers:
    - name: Перезапустить nginx
      service:
        name: nginx
        state: restarted

    - name: Перезапустить sshd
      service:
        name: sshd
        state: restarted

  tasks:
    - name: Установка пакета {{ package_name }}
      yum:
        name: "{{ package_name }}"
        state: present
      notify: Перезапустить nginx

    - name: Создание пользователя {{ app_user }}
      user:
        name: "{{ app_user }}"
        state: present
        shell: /bin/bash
        create_home: yes

    - name: Копирование конфигурационного файла nginx
      copy:
        src: files/nginx.conf
        dest: "{{ config_file }}"
        owner: root
        group: root
        mode: '0644'
      notify: Перезапустить nginx

    - name: Запуск и включение nginx
      service:
        name: nginx
        state: started
        enabled: yes

    - name: Перезапуск SSH (после изменений)
      service:
        name: sshd
        state: restarted
      notify: Перезапустить sshd
```

> **Объяснение новых элементов:**
> - `vars` — определение переменных,
> - `{{ variable }}` — использование переменной,
> - `notify` — вызывает handler **только при изменении**,
> - `handlers` — выполняются в конце play’а.

---

#### **Шаг 5: Подготовка файлов и запуск playbook’а**

Создайте директорию и файл конфигурации Nginx:

```bash
mkdir files
nano files/nginx.conf
```

Добавьте минимальный конфиг (для примера):

```nginx
events {
    worker_connections 1024;
}

http {
    server {
        listen 80;
        location / {
            return 200 'Hello from VM2 via Ansible!\n';
        }
    }
}
```

Запустите playbook:

```bash
ansible-playbook advanced_playbook.yml
```

> При первом запуске все задачи будут "changed". При повторном — "ok", если состояние не изменилось.

---

#### **Шаг 6: Проверка результата**

На VM2 проверьте:

```bash
systemctl status nginx
curl http://localhost
```

> Должен отобразиться текст: `Hello from VM2 via Ansible!`

---

#### **Шаг 7: Отладка и анализ**

Используйте флаги:
- `-v`, `-vv`, `-vvv` — увеличение уровня детализации,
- `--check` — режим "сухого" запуска (что будет изменено),
- `--diff` — показывает изменения в файлах.

Пример:

```bash
ansible-playbook advanced_playbook.yml --check --diff -v
```

---

### **Принципы написания Playbook’ов**

| Принцип | Описание |
|--------|---------|
| **Идемпотентность** | Запуск playbook’а несколько раз даёт один и тот же результат. |
| **Читаемость** | Используйте `name` для каждой задачи. |
| **Модульность** | Разделяйте задачи по ролям и файлам. |
| **Безопасность** | Не храните пароли в открытом виде; используйте `ansible-vault`. |
| **Переменные** | Выносите параметры в `vars`, чтобы легко менять конфигурацию. |
| **Handlers** | Используйте для перезапуска служб только при необходимости. |

---

### **Контрольные вопросы**
1. Что такое idempotency в контексте Ansible?
2. Чем отличается `command` от `shell` в playbook’е?
3. Для чего используются `handlers`?
4. Почему важно использовать переменные?
5. Как работает директива `notify`?

---

### **Вывод**

В ходе лабораторной работы:
- Были изучены основы написания Ansible Playbook’ов.
- Созданы простой и расширенный playbook’и.
- Применены переменные, обработчики, модули (`yum`, `user`, `copy`, `service`).
- Продемонстрирована идемпотентность и управление состоянием системы.
- Успешно настроен сервис (Nginx) на изолированной машине через бастион-хост.

Работа показывает, как Ansible позволяет описывать инфраструктуру как код (Infrastructure as Code), обеспечивая воспроизводимость, безопасность и масштабируемость.

---

**Примечания:**
- Все пути и имена пользователей соответствуют предыдущей лабораторной.
- При ошибках проверяйте права на файлы, наличие Python и корректность YAML.
- Для продвинутых сценариев рекомендуется использовать **роли (roles)** и **Vault**.
